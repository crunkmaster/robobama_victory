#!/usr/bin/env python
import roslib; roslib.load_manifest('robobama_victory')
import rospy
import sys
import atexit

from std_msgs.msg import Empty
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist
from ardrone_autonomy.msg import Navdata

trajectory = Twist()

def navdataCallback(msg):
    global trajectory
	
    drone_state = msg.state
    tags_count = msg.tags_count
    tags_xc = msg.tags_xc
    tags_yc = msg.tags_yc

    thresh = 50

    if tags_count != 1:
        sys.exit(0)
        
    x_pos = tags_xc[0]
    y_pos = tags_yc[0]

    x_distance = abs(320 - x_pos) # distance from middle of view
    y_distance = abs(230 - y_pos)

    print "distance_x: {0}".format(x_distance)
    print "distance_y: {0}".format(y_distance)

    if x_distance > thresh:
        if x_pos > 320:
			trajectory.linear.x = -0.5
        if x_pos < 320:
			trajectory.linear.x = 0.5
    if y_distance > thresh:
        if y_pos > 240:
			trajectory.linear.y = -0.5
        if y_pos < 240:
			trajectory.linear.y = 0.5

	controller_pub.publish(trajectory)

    # if neither of those happen, just stop all motors

    print "drone state: {0}".format(drone_state)
    print "drone state: {0}".format(drone_state)
    print "tags_count: {0}".format(tags_count)
    print "tags_xc: {0}".format(x_pos)
    print "tags_yc: {0}".format(y_pos)

if __name__ == "__main__":
    rospy.init_node("drone_controller")

    # publish an Empty message to /ardrone/takeoff
    takeoff = rospy.Publisher('/ardrone/takeoff', Empty).publish
    land = rospy.Publisher('/ardrone/land', Empty).publish

    flight_pub = rospy.Publisher('/cmd_vel', Twist)
    navdata_sub = rospy.Subscriber('/ardrone/navdata', Navdata,
                                    navdataCallback)

    # takeoff()
    # atexit.register(land) # make sure on exit, the drone will land

    traj = Twist()
    traj.linear.x = 0
    traj.linear.y = 0
    traj.linear.z = 0

    rospy.spin()
